---
title: "Summarizing the Runs"
output: 
  html_notebook:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
# set the working directory always to the project directory (one level up)
knitr::opts_knit$set(root.dir = normalizePath(rprojroot::find_rstudio_root_file())) 
```



## Try it with Nova Scotia, first

Let's slurp up the results, and let's make the names of the inferred and 
true hyb cats the same
```{r}
library(tidyverse)
library(viridis)

# get replacements for the true_hyb_cat column
thc <- c(
  PureF = "pure_farmed",
  PureW = "pure_wild",
  F1 = "F1",
  F2 = "F2",
  BX = "bx_wild"
)

nf_res <- read_rds("outputs/NF_long_runs_tibble.rds") %>%
  mutate(inferred_hyb_cat = as.character(inferred_hyb_cat),
         true_hyb_cat = thc[true_hyb_cat])
```

I have a harder time interpreting the "power = accuracy *  efficiency" summary than
I do looking at the receiver operating characteristic (ROC) curve.  The ROC curve is another summary
that includes both the type 1 and type 2 errors and which I find easier to get my head
around, so I will see what those look like in this case.


I think the ROC curve should be pretty easy to compute, using a sequence of scaled 
likelihoods from 0 to 1 in steps of 0.005, say.
One important point to keep in mind is that the false positive rate
must be a function of the true hybrid category.  We will honor that by
making a multipanel plot, creating ROC curves for all the different kinds of
situations (i.e. inferring F2's when the truth is BX, inferring F2's when the 
truth is Pure Wild, etc).

We can compute these ROC curves in the tidyverse by throwing down some `dplyr::do()`
along with the `ecdf()` function.  

```{r}
options(dplyr.show_progress = FALSE)
pos_rates <- nf_res %>%
  group_by(pop, true_hyb_cat, inferred_hyb_cat, num_loci) %>% 
  dplyr::do(
    tibble(
      pthresh = seq(0, 1, by = 0.005), 
      pgreater = 1 - ecdf(.$post_prob)(seq(0, 1, by = 0.005))
      )
    ) %>%
  ungroup()
```

Now, all we need to do is a quick left join to get ready to plot some of these:
```{r}
rocdf <- pos_rates %>%
  filter(true_hyb_cat == inferred_hyb_cat) %>%
  rename(true_pos_rate = pgreater,
         focal_hyb_cat = true_hyb_cat) %>%
  select(-inferred_hyb_cat) %>%
  left_join(., pos_rates) %>%
  filter(focal_hyb_cat != true_hyb_cat) %>%  # to give us an empty plot rather than a y = x line on the diagonal
  filter(focal_hyb_cat == inferred_hyb_cat) %>% # these are the values we care about
  rename(false_pos_rate = pgreater) %>%
  mutate(num_loci = factor(num_loci))
```

Let's see how these things plot out:
```{r}
dump <- lapply(unique(rocdf$pop), function(x) {
  g <- ggplot(rocdf %>% filter(pop == x), aes(x = false_pos_rate, y = true_pos_rate, colour = num_loci)) +
    geom_line() +
    facet_grid(focal_hyb_cat ~ true_hyb_cat) + 
    ggtitle(x) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
  
  ggsave(g, filename = paste0("outputs/roc_NF_", x, ".pdf"))
})

```

I saved these in the files `roc_NF_XXX.pdf`. 
The way to interpret these is this: when you are looking up and down the columns
you are assessing what the true positive rate is for the hybrid category that is
listed at the top of the column as a function of the false positive rate for the 
hybrid category that is listed to the right.  So, for example, if you are trying 
to identify F2s in the BDN population, and you have 48 loci, then when you set your
F2 posterior probability to $T$, such that 75% of the F2s you encounter are expected to have
a posterior $\geq T$, you expect that 25% of bx_wild fish will also have an
F2 posterior $\geq T$.  This informtion can be gleaned from the graph in the 
first row and the third column. 

That is pretty cool, but if we wanted to also try to show what the scaled likelihood
cutoff levels are, we can do that too.
```{r}
dump <- lapply(unique(rocdf$pop), function(x) {
  g <- ggplot(rocdf %>% filter(pop == x), aes(x = false_pos_rate, y = true_pos_rate, colour = pthresh,
                                              group = num_loci)) +
    geom_line() +
    facet_grid(focal_hyb_cat ~ true_hyb_cat) + 
    ggtitle(x) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
    scale_colour_viridis()
  
  ggsave(g, filename = paste0("outputs/roc_NF_pcolor", x, ".pdf"))
})
```

What we see there is that with 48 loci, if you want a true positive rate of
75% for F2s, you are going to have to use a posterior probability cutoff that looks
to be around 30%, which makes it clear why you'd suffer pretty high false positive
rates from the bx_wild category.  

### Hybrid vs non-hybrid

In addition to the above, it would be nice to see for each true hybrid category, how well one
can do with just declaring a fish a hybrid (of some sort) or not.  This shouldn't be too hard to 
get at.  We just want to collapse the inferred hybrid category down to hybrid or non-hybrid.  And then
we have to do a little bit more to make sure that the 
```{r}
nf_squash <- nf_res %>%
  mutate(inferred_hyb_cat = ifelse(inferred_hyb_cat %in% c("pure_farmed", "pure_wild"), "pure", "hybrid")) %>%
  group_by(split, pop, true_hyb_cat, num_loci, idx, inferred_hyb_cat) %>%
  summarise(post_prob = sum(post_prob)) %>%
  ungroup() %>%
  mutate(true_cat_squash = ifelse(true_hyb_cat %in% c("pure_farmed", "pure_wild"), "pure", "hybrid"))
```

Now, we can just run that back through the same few commands to do ROC curves.
```{r}
pos_rates_squash <- nf_squash %>%
  group_by(pop, true_hyb_cat, inferred_hyb_cat, num_loci) %>% 
  dplyr::do(
    tibble(
      pthresh = seq(0, 1, by = 0.005), 
      pgreater = 1 - ecdf(.$post_prob)(seq(0, 1, by = 0.005))
      )
    ) %>%
  ungroup()

rocdf_squash <- pos_rates_squash %>%
  filter(true_cat_squash == inferred_hyb_cat) %>%
  rename(true_pos_rate = pgreater,
         focal_hyb_cat = true_hyb_cat) %>%
  select(-inferred_hyb_cat) %>%
  left_join(., pos_rates_squash) %>%
  filter(true_cat_squash == inferred_hyb_cat) %>% # these are the values we care about
  rename(false_pos_rate = pgreater) %>%
  mutate(num_loci = factor(num_loci))
```

```{r}
dump <- lapply(unique(rocdf_squash$pop), function(x) {
  g <- ggplot(rocdf_squash %>% filter(pop == x), aes(x = false_pos_rate, y = true_pos_rate, colour = num_loci)) +
    geom_line() +
    facet_grid(focal_hyb_cat ~ true_hyb_cat) + 
    ggtitle(x) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
  
  ggsave(g, filename = paste0("outputs/squash_roc_NF_", x, ".pdf"))
})

```